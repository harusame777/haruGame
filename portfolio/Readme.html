<!DOCTYPE html>
<html>
<head>
<title>Readme.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="salvage">SALVAGE</h1>
<blockquote>
<h3 id="%E6%B2%B3%E5%8E%9F%E9%9B%BB%E5%AD%90%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9-%E3%82%B2%E3%83%BC%E3%83%A0%E3%82%AF%E3%83%AA%E3%82%A8%E3%82%A4%E3%82%BF%E3%83%BC%E7%A7%91">河原電子ビジネス ゲームクリエイター科</h3>
<h3 id="%E6%B0%8F%E5%90%8D%E6%AD%A6%E7%94%B0-%E6%82%A0%E4%B8%96-%E3%81%9F%E3%81%91%E3%81%A0-%E3%81%AF%E3%82%8B%E3%81%9B">氏名：武田 悠世 （たけだ はるせ）</h3>
</blockquote>
<h1 id="%E7%9B%AE%E6%AC%A1">目次</h1>
<ul>
<li><a href="#salvage">SALVAGE</a></li>
<li><a href="#%E7%9B%AE%E6%AC%A1">目次</a>
<ul>
<li><a href="#%E4%BD%9C%E5%93%81%E6%A6%82%E8%A6%81">作品概要</a></li>
</ul>
</li>
<li><a href="#1%E4%BD%9C%E6%88%90%E3%81%97%E3%81%9F%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89">1.作成したソースコード</a></li>
<li><a href="#2%E4%BD%9C%E6%88%90%E3%81%97%E3%81%9F%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%B3%E3%82%B3%E3%83%BC%E3%83%89">2.作成したエンジンコード</a></li>
<li><a href="#3%E4%BD%9C%E6%88%90%E3%81%97%E3%81%9F%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC">3.作成したシェーダー</a></li>
<li><a href="#4%E3%82%B2%E3%83%BC%E3%83%A0%E8%AA%AC%E6%98%8E">4.ゲーム説明</a>
<ul>
<li><a href="#4-1%E3%83%97%E3%83%AC%E3%82%A4%E3%83%A4%E3%83%BC%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">4-1.プレイヤーについて</a></li>
<li><a href="#4-2%E3%82%B9%E3%82%BF%E3%83%9F%E3%83%8Aui%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">4-2.スタミナUIについて</a></li>
<li><a href="#4-3%E9%85%B8%E7%B4%A0ui%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">4-3.酸素UIについて</a></li>
<li><a href="#4-4%E3%82%B9%E3%82%B3%E3%82%A2ui%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">4-4.スコアUIについて</a></li>
<li><a href="#4-5%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%81%E3%83%A3%E3%83%BC%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">4-5.クリーチャーについて</a></li>
<li><a href="#4-6%E3%82%AF%E3%83%AA%E3%82%B9%E3%82%BF%E3%83%AB%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">4-6.クリスタルについて</a></li>
<li><a href="#4-7%E3%82%A6%E3%82%A3%E3%83%B3%E3%83%89%E3%82%A6%E3%82%A4%E3%83%B3%E3%83%95%E3%82%A9%E3%83%A1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">4-7.ウィンドウインフォメーションについて</a></li>
</ul>
</li>
<li><a href="#5%E6%93%8D%E4%BD%9C%E8%AA%AC%E6%98%8E">5.操作説明</a></li>
<li><a href="#6%E6%8A%80%E8%A1%93%E7%B4%B9%E4%BB%8B">6.技術紹介</a>
<ul>
<li><a href="#6-1%E3%82%B9%E3%83%86%E3%83%BC%E3%83%88%E3%83%9E%E3%82%B7%E3%83%B3">6-1.ステートマシン</a></li>
<li><a href="#6-2%E9%9B%86%E5%9B%A3%E5%88%B6%E5%BE%A1%E3%83%A1%E3%82%BF%EF%BD%81%EF%BD%89">6-2.集団制御(メタＡＩ)</a></li>
<li><a href="#6-3%E5%B7%9D%E7%80%AC%E5%BC%8Fbloom%E3%83%95%E3%82%A3%E3%83%AB%E3%82%BF%E3%83%BC%E3%81%AE%E5%AE%9F%E8%A3%85">6-3.川瀬式Bloomフィルターの実装</a></li>
<li><a href="#6-5vsm%E3%81%AE%E5%AE%9F%E8%A3%85">6-5.VSMの実装</a></li>
<li><a href="#6-4%E7%AB%8B%E4%BD%93%E9%9F%B3">6-4.立体音</a></li>
<li><a href="#6-5%E3%83%87%E3%83%90%E3%83%83%E3%82%B0%E6%A9%9F%E8%83%BD">6-5.デバッグ機能</a></li>
</ul>
</li>
</ul>
<br />
<p><a id = "anchor1"></a></p>
<h2 id="%E4%BD%9C%E5%93%81%E6%A6%82%E8%A6%81">作品概要</h2>
<blockquote>
<dl>
<dt>タイトル</dt>
<dd>SALVAGE</dd>
<dt>制作期間</dt>
<dd>2024年8月から現在まで</dd>
<dt>ゲームジャンル</dt>
<dd>ホラーゲーム</dd>
<dt>プレイ人数</dt>
<dd>一人</dd>
<dt>使用言語</dt>
<dd>C++</dd>
<dd>HLSL</dd>
<dt>使用ツール</dt>
<dd>Visual Studio 2022</dd>
<dd>Visual Studio Code</dd>
<dd>Adobe Photoshop 2025</dd>
<dd>3ds Max 2024</dd>
<dd>Effekseer</dd>
<dd>GitHub</dd>
<dd>Fork</dd>
<dd>Trello</dd>
<dt>開発環境</dt>
<dd>学校内製の簡易エンジン</dd>
<dd>Windows11</dd>
<dt>GitHubのURL</dt>
<a href="https://github.com/harusame777/haruGame"><dd>https://github.com/harusame777/haruGame</dd></a>
<dd>プレイ動画のURL</dd>
<a href="https://youtu.be/jW00RJZBNB4"><dd>https://youtu.be/jW00RJZBNB4</dd></a>
</dl>
</blockquote>
<br />
<p><a id = "anchor2"></a></p>
<h1 id="1%E4%BD%9C%E6%88%90%E3%81%97%E3%81%9F%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89">1.作成したソースコード</h1>
<blockquote>
<ul>
<li>Accessories.cpp</li>
<li>Accessories.h</li>
<li>BackGroundCeiling.cpp</li>
<li>BackGroundCeiling.h</li>
<li>BackGroundFloor.cpp</li>
<li>BackGroundFloor.h</li>
<li>BackGroundWalls.cpp</li>
<li>BackGroundWalls.h</li>
<li>BootObjectBase.cpp</li>
<li>BootObjectBase.h</li>
<li>Crystal.cpp</li>
<li>Crystal.h</li>
<li>CrystalDataHolder.h</li>
<li>CrystalGetCommandSprite.cpp</li>
<li>CrystalGetCommandSprite.h</li>
<li>DebugEnemyTrackingState.cpp</li>
<li>DebugEnemyTrackingState.h</li>
<li>Elevator.cpp</li>
<li>Elevator.h</li>
<li>Enemy_Warrior.cpp</li>
<li>Enemy_Warrior.h</li>
<li>EnemyAIBase.cpp</li>
<li>EnemyAIBase.h</li>
<li>EnemyAIConBase.cpp</li>
<li>EnemyAIConBase.h</li>
<li>EnemyAIConColPlayer.cpp</li>
<li>EnemyAIConColPlayer.h</li>
<li>EnemyAIConSearch.cpp</li>
<li>EnemyAIConSearch.h</li>
<li>EnemyAIConWaitTime.cpp</li>
<li>EnemyAIConWaitTime.h</li>
<li>EnemyAIConWallSearch.cpp</li>
<li>EnemyAIConWallSearch.h</li>
<li>EnemyAIMetaBase.cpp</li>
<li>EnemyAIMetaBase.h</li>
<li>EnemyAIMetaWarrior.cpp</li>
<li>EnemyAIMetaWarrior.h</li>
<li>EnemyAIMove.cpp</li>
<li>EnemyAIMove.h</li>
<li>EnemyAIMoveAstar.cpp</li>
<li>EnemyAIMoveAstar.h</li>
<li>EnemyBase.cpp</li>
<li>EnemyBase.h</li>
<li>EnemySM_Warrior.cpp</li>
<li>EnemySM_Warrior.h</li>
<li>EnemySMBase.cpp</li>
<li>EnemySMBase.h</li>
<li>EnemyWarriorTrackingState.h</li>
<li>Game.cpp</li>
<li>Game.h</li>
<li>GameCamera.cpp</li>
<li>GameCamera.h</li>
<li>Gameover.cpp</li>
<li>Gameover.h</li>
<li>GameSound.cpp</li>
<li>GameSound.h</li>
<li>Load.cpp</li>
<li>Load.h</li>
<li>Locker.cpp</li>
<li>Locker.h</li>
<li>ManagerCrystal.cpp</li>
<li>ManagerCrystal.h</li>
<li>ObjectBase.cpp</li>
<li>ObjectBase.h</li>
<li>PatrolRuteDataHolder.h</li>
<li>Player.cpp</li>
<li>Player.h</li>
<li>PlayerOxygenUi.cpp</li>
<li>PlayerOxygenUi.h</li>
<li>PlayerScanCrystalUi.cpp</li>
<li>PlayerScanCrystalUi.h</li>
<li>PlayerScoreUi.cpp</li>
<li>PlayerScoreUi.h</li>
<li>PlayerStaminaUi.cpp</li>
<li>PlayerStaminaUi.h</li>
<li>PlayerUIBase.h</li>
<li>Result.cpp</li>
<li>Result.h</li>
<li>Title.cpp</li>
<li>Title.h</li>
<li>WarriorAIMetaFootSteps.cpp</li>
<li>WarriorAIMetaFootSteps.h</li>
<li>WarriorAIMetapPatrol.cpp</li>
<li>WarriorAIMetapPatrol.h</li>
<li>WarriorAIMetaRetreat.cpp</li>
<li>WarriorAIMetaRetreat.h</li>
<li>WarriorAIMetaStop.cpp</li>
<li>WarriorAIMetaStop.h</li>
<li>WarriorAIMetaTracking.cpp</li>
<li>WarriorAIMetaTracking.h</li>
<li>WarriorDataHolder.h</li>
<li>Window.cpp</li>
<li>Window.h</li>
</ul>
</blockquote>
<br />
<p><a id = "anchor3"></a></p>
<h1 id="2%E4%BD%9C%E6%88%90%E3%81%97%E3%81%9F%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%B3%E3%82%B3%E3%83%BC%E3%83%89">2.作成したエンジンコード</h1>
<blockquote>
<ul>
<li>DirectionalLight.cpp</li>
<li>DirectionalLight.h</li>
<li>FontRender.cpp</li>
<li>FontRender.h</li>
<li>IRenderer.h</li>
<li>LevelRender.cpp</li>
<li>LevelRender.h</li>
<li>LuminnceRender.cpp</li>
<li>LuminnceRender.h</li>
<li>ModelRender.cpp</li>
<li>ModelRender.h</li>
<li>PointLight.cpp</li>
<li>PointLight.h</li>
<li>RenderingEngine.cpp</li>
<li>RenderingEngine.h</li>
<li>SceneLight.cpp</li>
<li>SceneLight.h</li>
<li>ShadowMapRender.cpp</li>
<li>ShadowMapRender.h</li>
<li>SpotLight.cpp</li>
<li>SpotLight.h</li>
<li>SpriteRender.cpp</li>
<li>SpriteRender.h</li>
</ul>
</blockquote>
<br />
<p><a id = "anchor4"></a></p>
<h1 id="3%E4%BD%9C%E6%88%90%E3%81%97%E3%81%9F%E3%82%B7%E3%82%A7%E3%83%BC%E3%83%80%E3%83%BC">3.作成したシェーダー</h1>
<blockquote>
<ul>
<li>haruharuCircularGaugeSprite.fx</li>
<li>haruharuCrystalModel.fx</li>
<li>haruharuDeaphShadowReceiverModel.fx</li>
<li>haruharuDrawDeaphShadowMap.fx</li>
<li>haruharuDrawShadowMap.fx</li>
<li>haruharuLoadSpriteShader.fx</li>
<li>haruharuModel.fx</li>
<li>haruharuOxygenGaugeSpriteShader.fx</li>
<li>haruharuPostEffect.fx</li>
<li>haruharuRenderToGBufferFor3DModel.fx</li>
<li>haruharuShadowReceiverModel.fx</li>
<li>haruharuSprite.fx</li>
<li>harmuharuStaminaBarSpriteShader.fx</li>
<li>haruharuWindowSpriteShader.fx</li>
<li>haruharuWipeSprite.fx</li>
<li>haruharuWipeSpriteMoveVer.fx</li>
</ul>
</blockquote>
<br />
<p><a id = "anchor5"></a></p>
<h1 id="4%E3%82%B2%E3%83%BC%E3%83%A0%E8%AA%AC%E6%98%8E">4.ゲーム説明</h1>
<blockquote>
<h3 id="%E3%81%93%E3%81%AE%E3%82%B2%E3%83%BC%E3%83%A0%E3%81%AF%E5%BB%83%E7%A0%94%E7%A9%B6%E6%89%80%E3%81%AB%E4%BE%B5%E5%85%A5%E3%81%97%E3%81%9F%E4%B8%BB%E4%BA%BA%E5%85%AC%E3%81%8C%E7%A0%94%E7%A9%B6%E6%89%80%E5%86%85%E9%83%A8%E3%81%AB%E3%81%82%E3%82%8B%E9%89%B1%E7%9F%B3%E3%82%92dd">このゲームは廃研究所に侵入した主人公が研究所内部にある鉱石を</dd></h3>
<h3 id="%E6%AE%8B%E3%82%8A%E9%85%B8%E7%B4%A0%E3%81%8C%E7%B6%9A%E3%81%8F%E9%99%90%E3%82%8A%E6%8E%A1%E5%8F%96%E3%81%97%E3%81%A6%E5%86%85%E9%83%A8%E3%81%AB%E3%81%84%E3%82%8B%E3%83%A2%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%BC%E3%81%AB%E8%A5%B2%E3%82%8F%E3%82%8C%E3%81%AA%E3%81%84%E3%82%88%E3%81%86%E3%81%ABdd">残り酸素が続く限り採取して、内部にいるモンスターに襲われないように</dd></h3>
<h3 id="%E7%A0%94%E7%A9%B6%E6%89%80%E3%81%8B%E3%82%89%E8%84%B1%E5%87%BA%E3%81%99%E3%82%8B%E3%83%9B%E3%83%A9%E3%83%BC%E6%8E%A1%E5%8F%96%E3%82%B2%E3%83%BC%E3%83%A0%E3%81%A7%E3%81%99dd">研究所から脱出するホラー採取ゲームです</dd></h3>
<h3 id="%E9%85%B8%E7%B4%A0%E3%82%B2%E3%83%BC%E3%82%B8%E3%81%8C%E3%81%AA%E3%81%8F%E3%81%AA%E3%82%8B%E5%89%8D%E3%81%AB%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%A0%E3%81%91%E5%A4%9A%E3%81%8F%E3%81%AE%E9%89%B1%E7%9F%B3%E3%82%92%E6%8E%A1%E5%8F%96%E3%81%99%E3%82%8B%E3%81%AE%E3%81%8C%E7%9B%AE%E7%9A%84%E3%81%AEdd">酸素ゲージがなくなる前に、できるだけ多くの鉱石を採取するのが目的の</dd></h3>
<h3 id="%E3%82%B2%E3%83%BC%E3%83%A0%E3%81%A7%E3%81%99">ゲームです。</h3>
<p>メインゲーム画面
<img src="image1.png" alt="alt text">
<img src="image2.png" alt="alt text"></p>
</blockquote>
<br />
<p><a id = "anchor5-1"></a></p>
<h2 id="4-1%E3%83%97%E3%83%AC%E3%82%A4%E3%83%A4%E3%83%BC%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">4-1.プレイヤーについて</h2>
<blockquote>
<dl>
<dt>実装方式</dt>
<dt>FPS視点について</dt>
<dd>カメラをマップのちょうどプレイヤーの視点の高さに来るように配置し、そのカメラをキャラクターコントローラーに追従させる形で実装しました。</dd>
<dt>ダッシュについて</dt>
<dd>キャラクタークラス内でスタミナUIのインスタンスを取得し、そのインスタンスにスタミナ変数の値を渡すことによって外部出力を行っています。</dd>
<p><img src="gif_image1.gif" alt="alt text"></p>
<dt>工夫した点</dt>
<dt>なぜFPSか</dt>
<dd>FPSにすることにより、モンスターに追われる際や、モンスターから隠れている状況でより緊張感が生まれ、よりゲームに没入し楽しめるのではないかと思ったからです。</dd>
<dd>後述する方法で音を三次元的に表現しているため、FPS視点もあいまって、かなりリアルに近い緊張感を感じる事ができます。</dd>
</dl>
</blockquote>
<br />
<p><a id = "anchor5-2"></a></p>
<h2 id="4-2%E3%82%B9%E3%82%BF%E3%83%9F%E3%83%8Aui%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">4-2.スタミナUIについて</h2>
<blockquote>
<dl>
<dt>実装方式</dt>
<dt>UIの動きについて</dt>
<dd>UIの枠とゲージを別々に描画し、ゲージの方を円形ワイプを応用して増減を表現しました。そして、プレイヤー側のスタミナ変数の割合でゲージの割合を制御することでスタミナの数値によってスタミナゲージが変化するように設計しました。</dd>
<dt>以下はUIの動きの映像になります。</dt>
<p><img src="gif_image2.gif" alt="alt text"></p>
<p><img src="gif_image2_cat.gif" alt="alt text"></p>
<dt>工夫した点</dt>
<dt>プログラムの設計</dt>
<dd>外部から変数を設定できるようにし、再利用性を高め、変数の変更等があったりした時に対応できるようにしました。</dd>
<dt>演出面</dt>
<dd>スタミナ低下時にスタミナを点滅させるようにし、またスタミナがなくなった時はスタミナを赤く点滅させるようにして、ユーザーから見てスタミナの状態が分かりやすいようにしました。</dd>
</dl>
</blockquote>
<br />
<p><a id = "anchor5-3"></a></p>
<h2 id="4-3%E9%85%B8%E7%B4%A0ui%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">4-3.酸素UIについて</h2>
<blockquote>
<dl>
<dt>実装方式</dt>
<dt>UIの動きについて<dt>
<dd>ゲージは通常のワイプを使用し増減を表現しました。そして、ゲーム側のタイマー変数の割合でゲージの割合を制御する事でタイマーの数値によってゲージが変化するように設計しました。</dd>
<dt>以下はUIの動きの映像になります。</dt>
<p><img src="gif_image3.gif" alt="alt text"></p>
<p><img src="gif_image3_cat.gif" alt="alt text"></p>
<dt>工夫した点</dt>
<dt>プログラムの設計</dt>
<dd>こちらもスタミナゲージと同じく、外部から変数を設定できるようにし、再利用性を高め、変数の変更等の理由があったりした時に対応できるようにしました。</dd>
<dt>演出面</dt>
<dd>タイマーが半分以下になった際にゲージを黄色に変更するようにし、タイマーが1分以下になった際にゲージを赤色にし、点滅させ、ユーザーに緊張感と焦りを与えよりスリルを味わえるようにしました。</dd>
</blockquote>
</dl>
<br />
<p><a id = "anchor5-4"></a></p>
<h2 id="4-4%E3%82%B9%E3%82%B3%E3%82%A2ui%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">4-4.スコアUIについて</h2>
<blockquote>
<dl>
<dt>実装方式</dt>
<dt>UIの動きについて</dt>
<dd>スコアは学校側のエンジンの元々の昨日である文字描画で表現しました。そして、クリスタルのクラス内の関数から、スコアUI内の関数に増加分の数値を引数として設定、実行することでスコアの増減を行えるように設計しました。</dd>
<dt>以下はUIの動きの映像になります。</dt>
<p><img src="gif_image4.gif" alt="alt text"></p>
<p><img src="gif_image4_cat.gif" alt="alt text"></p>
<dt>工夫した点</dt>
<dt>増減の表現方式</dt>
<dd>増減の表現方式として、スコアを加算する際に、スコア加算分を計算したスコアに向けて、現在表示中のUIの変数を少しずつ増やす方式を取りました。こうする事で、デジタル感が表現できて、世界観にとてもマッチしているので、作ってよかったと思いました。</dd>
</blockquote>
</dl>
<br />
<p><a id = "anchor5-5"></a></p>
<h2 id="4-5%E3%82%AF%E3%83%AA%E3%83%BC%E3%83%81%E3%83%A3%E3%83%BC%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">4-5.クリーチャーについて</h2>
<blockquote>
<dl>
<dt>実装方式</dt>
<dt>仕様</dt>
<dd>・数は全部で3体</dd>
<dd>・特殊能力等の設定などはない</dd>
<dd>・研究所をうろついている実験動物みたいなイメージ</dd>
<dt>行動について</dt>
<dd>行動は全部で3パターンあり、それぞれ、巡回、追跡、待機、となっている。
<dd>巡回状態では、エネミー生成時に設定される、いくつかのステージ内の座標を目的地とし、そこに向かって学校エンジン製のナビメッシュを使用したパス移動を行う、これをプレイヤーが見つかるか、目的地に到達する、後述するメタAIから指示が出るまで繰り返す。</dd>
<dd>追跡状態では、プレイヤーの座標を取得し、その座標を目的地としてナビメッシュを使用したパス移動、またはキャラクターコントローラーを使用した移動を行う、プレイヤーと自身の間に、壁があるかないかで、パス移動をするかキャラクターコントローラー移動をするかを切り替え、自然な移動、追跡をすることができる。こちらは、プレイヤーに自身が接触するか、プレイヤーを見失うまで繰り返す。
</dd>
<dd>待機状態では、３秒待ってから、次の巡回位置の決定をし、巡回へと行動を切り替える処理を行う。</dd>
</blockquote>
<br />
<p><a id = "anchor5-6"></a></p>
<h2 id="4-6%E3%82%AF%E3%83%AA%E3%82%B9%E3%82%BF%E3%83%AB%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">4-6.クリスタルについて</h2>
<blockquote>
<dl>
<dt>実装方式</dt>
<dt>仕様</dt>
<dd>・同時スポーンは3個まで</dd>
<dd>・発生場所はランダム</dd>
<dd>・一度採取した場合は5秒後に別の場所にリスポーンする</dd>
<dt>採取方法</dt>
<dd>視点を合わせ、Bボタンを押すと、採取コマンドが出現する、採取コマンドの真ん中にはA、B、X、Yのうちどれかが表示されており、対応しているボタンを時間内に押すと、次のコマンドが表示される、これを5回繰り返すと採取成功となり、スコアが加算される。
<dt>工夫した点</dt>
<dt>設置プログラム</dt>
<dd>クリスタル全体を管理するプログラムを作成し、マップの設置場所をレベルから取得し初期設置を行ったり、常に取得されたかどうかを監視し、取得されたら再設置タイマーを設定、再設置まで行うように設計しました。</dd>
<dt>採取コマンドのスプライト</dt>
<dd>採取コマンドのスプライトは動きをこだわりました、ツルハシの回転をイージングで行い動きをつけました。残りコマンド時間が分かりやすいように残り時間で、コマンド周辺の円が円形ワイプで減少するように作りました。</dd>
</dl>
</blockquote>
<br />
<p><a id = "anchor5-7"></a></p>
<h2 id="4-7%E3%82%A6%E3%82%A3%E3%83%B3%E3%83%89%E3%82%A6%E3%82%A4%E3%83%B3%E3%83%95%E3%82%A9%E3%83%A1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6">4-7.ウィンドウインフォメーションについて</h2>
<blockquote>
<dl>
<dt>実装方式</dt>
<dt>UIの動きについて</dt>
<dd>スプライトは、一番下に、文字を表示させる場所である、ウィンドウベースを作成し、その上に、ウィンドウの枠である、ウィンドウバーを描画する構成にしています。そして、ウィンドウバーを上下に動かす際に、ウィンドウベースを上下からワイプすることによって、ウィンドウの開け閉めの演出をしています。</dd>
<dt>以下はUIの動きの映像になります。</dt>
<p><img src="gif_image5.gif" alt="alt text"></p>
<dt>工夫した点</dt>
<dt>ワイプ方式</dt>
<dd>ウィンドウバーの上下によってワイプの割合を調整する方法は、上部のウィンドウバーの開閉割合を使用して、ウィンドウワイプの割合を計算することによって実現しました。</dd>
<dt>文字表示形式</dt>
<dd>ウィンドウインフォメーションを簡単に使いまわせるように、文字表示は外部クラスから簡単にインプットできるように設計しました。</dd>
<dt>小機能</dt>
<dd>文字表示中にBボタンを押すことで、文字送りが行われる機能を追加しました。</dd>
</blockquote>
<br />
<p><a id = "anchor6"></a></p>
<h1 id="5%E6%93%8D%E4%BD%9C%E8%AA%AC%E6%98%8E">5.操作説明</h1>
<blockquote>
<p><img src="image3.png" alt="alt text"></p>
</blockquote>
<br />
<p><a id = "anchor7"></a></p>
<h1 id="6%E6%8A%80%E8%A1%93%E7%B4%B9%E4%BB%8B">6.技術紹介</h1>
<br />
<p><a id = "anchor8"></a></p>
<h2 id="6-1%E3%82%B9%E3%83%86%E3%83%BC%E3%83%88%E3%83%9E%E3%82%B7%E3%83%B3">6-1.ステートマシン</h2>
<blockquote>
<p>実装理由:プログラムの順序を分かりやすく視覚化しておくことによって、
プログラムの制御や追加がやりやすくなるため。</p>
<p>例：モンスターのステートマシン
<img src="image4.png" alt="alt text"></p>
</blockquote>
<br />
<p><a id = "anchor9"></a></p>
<h2 id="6-2%E9%9B%86%E5%9B%A3%E5%88%B6%E5%BE%A1%E3%83%A1%E3%82%BF%EF%BD%81%EF%BD%89">6-2.集団制御(メタＡＩ)</h2>
<blockquote>
<p>実装理由:モンスター3体の集団制御のため</p>
<dl>
<dt>3体存在しているクリーチャーを連携させて動かす為に実装しました。
<dt>実装方式</dt>
<dt>1.集団制御クラスを作成する</dt>
<dd>まずは、集団制御クラスを作成しました、基本的なクラスは構成としてはメタAIのメインプログラムのクラス、メタAIの実行処理を行う実行プログラムの基底クラスの二つで構成しました。基底クラスを作った理由は、基底クラスを作ることで、追加設計がしやすくなり、管理のしやすさも向上すると考えたためです。</dd>
<dt>2.メタAIの基底クラスを使い実行プログラムを作成する</dt>
<dd>次にメタAIの実行プログラムを用途によって複数作りました、停止、起動、巡回、追跡、等のクリーチャー全体に影響を及ぼすプログラムを作成しました。そしてこれらのプログラムのインスタンスをメインプログラムの配列に設定、メインプログラムの外部から列挙型を使い実行プログラムを指定、起動、実行できるように設計しました。
<dt>以下は実際のメタAIの形式です</dt>
<p><img src="image5.png" alt="alt text"></p>
<dt>
<dl>
</blockquote>
<br />
<p><a id = "anchor10"></a></p>
<h2 id="6-3%E5%B7%9D%E7%80%AC%E5%BC%8Fbloom%E3%83%95%E3%82%A3%E3%83%AB%E3%82%BF%E3%83%BC%E3%81%AE%E5%AE%9F%E8%A3%85">6-3.川瀬式Bloomフィルターの実装</h2>
<blockquote>
<p>実装理由:暗がりでの光をよりリアルに見せるため</p>
<dl>
<dt>実装方式</dt>
<dt>1.輝度抽出用のレンダリングターゲットを作成する。</dt>
<dd>本書や、サンプルプログラムでは、同じくレンダリングエンジンのプログラムファイルに記載されているが</dd>
<dd>今回はプログラム量の多さから、分かりにくくなってしまうためプログラムをクラスにして別に実装した。
<dd>説明上の分かりやすさのため輝度抽出クラスと呼びます。</dd>
<dd>この輝度抽出クラスをレンダリングエンジン側でメンバ変数として宣言、レンダリングエンジンの
<dd>初期化の際共に初期化し、その初期化のタイミングでレンダリングターゲットが作成される。
<dd>この初期化の際には、ほかにも</dd>
<dd>・輝度抽出用のスプライトの初期化</dd>
<dd>・ガウシアンブラークラスの初期化、ぼかすテクスチャのアドレスの設定</dd>
<dd>・生成したボケ画像を合成するスプライトの初期化
<dd>などが行われている。</dd>
<dt>2.輝度抽出をするタイミングでレンダリングターゲットを作成したものに変更する。</dt>
<dd>レンダリングターゲットをモデルの描画やライトの処理をしたレンダリングターゲットから変更する。
<dd>輝度抽出クラスの関数に変更からその後の処理までがプログラムされているため</dd>
<dd>関数から抜ける頃には輝度抽出の処理は終わっている。</dd>
<dt>3.ガウシアンブラーの実行</dt>
<dd>通常のBloomとは違い複数回ガウシアンブラーを実行します。こうすることで、光のあふれテクスチャを</dd>
<dd>生成することができます。</dd>
<dt>4.ボケ画像を合成しメインレンダリングターゲットに加算する</dt>
<dd>シェーダー側でボケ画像を合成し、メインレンダリングターゲットにレンダリングターゲットを変更</dd>
<dd>合成します。</dd>
<dd>この合成スプライトは輝度抽出クラスで宣言、初期化されているため、レンダリングエンジンのプログラム</dd>
<dd>から、輝度抽出クラスのメンバ変数を使ってクラスにあるドローコール関数を実行します。
<dd>これにより、川瀬式Bloomフィルターを使用した輝度抽出から合成描画までが完了します。</dd>
</dl>
</blockquote>
<blockquote>
<p>以下輝度抽出_合成描画用のシェーダーのプログラム</p>
<pre class="hljs"><code><div>
cbuffer cb : register(b<span class="hljs-number">0</span>)
{
    float4x4 mvp;       <span class="hljs-regexp">//</span> MVP行列
    float4 mulColor;    <span class="hljs-regexp">//</span> 乗算カラー
};

struct VSInput
{
    float4 pos : POSITION;
    float2 uv  : TEXCOORD<span class="hljs-number">0</span>;
};

struct PSInput
{
    float4 pos : SV_POSITION;
    float2 uv  : TEXCOORD<span class="hljs-number">0</span>;
};

<span class="hljs-regexp">/*!
 * @brief 頂点シェーダー
 */</span>
PSInput VSMain(VSInput In)
{
    PSInput psIn;
    psIn.pos = mul(mvp, In.pos);
    psIn.uv = In.uv;
    <span class="hljs-keyword">return</span> psIn;
}

Texture2D&lt;float4&gt; mainRenderTargetTexture : register(t<span class="hljs-number">0</span>); <span class="hljs-regexp">//</span> メインレンダリングターゲットのテクスチャ
sampler Sampler : register(s<span class="hljs-number">0</span>);

<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">/
/</span><span class="hljs-regexp">/ 輝度抽出用
/</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span>
/*!
 * @brief 輝度抽出用のピクセルシェーダー
 *<span class="hljs-regexp">/
float4 PSLuminance(PSInput In) : SV_Target0
{
    /</span><span class="hljs-regexp">/ 輝度を抽出するピクセルシェーダーを実装
    float4 color = mainRenderTargetTexture.Sample(Sampler, In.uv);
    
    /</span><span class="hljs-regexp">/ サンプリングされたカラーの明るさを計算
    float t = dot(color.xyz, float3(0.2125f, 0.7154f, 0.0721f));
    
    /</span><span class="hljs-regexp">/ clip関数は引数の値がマイナスになると以降の処理をスキップする
    /</span><span class="hljs-regexp">/ なので、マイナスになるとピクセルカラーは出力されない
    /</span><span class="hljs-regexp">/ 今回の実装はカラーの明るさが1以下ならピクセルキルする
    clip(t - 0.9f);
    
    return color;
}

/</span><span class="hljs-regexp">/ ボケ画にアクセスする為の変数
Texture2D&lt;float4&gt; g_bokeTexture_0 : register(t0);
Texture2D&lt;float4&gt; g_bokeTexture_1 : register(t1);
Texture2D&lt;float4&gt; g_bokeTexture_2 : register(t2);
Texture2D&lt;float4&gt; g_bokeTexture_3 : register(t3);

/</span><span class="hljs-regexp">/ ボケ画像合成用のピクセルシェーダー
float4 PSBloomFinal(PSInput In) : SV_Target0
{
    /</span><span class="hljs-regexp">/ ボケ画像を合成
    float4 combineColor = g_bokeTexture_0.Sample(Sampler, In.uv);
    combineColor += g_bokeTexture_1.Sample(Sampler, In.uv);
    combineColor += g_bokeTexture_2.Sample(Sampler, In.uv);
    combineColor += g_bokeTexture_3.Sample(Sampler, In.uv);
    combineColor /</span>= <span class="hljs-number">4.0</span>f;
    combineColor.a = <span class="hljs-number">1.0</span>f;
    <span class="hljs-keyword">return</span> combineColor;
}

</div></code></pre>
</blockquote>
<br />
<p><a id = "anchor11"></a></p>
<h2 id="6-5vsm%E3%81%AE%E5%AE%9F%E8%A3%85">6-5.VSMの実装</h2>
<blockquote>
<dl>
<dt>実装理由：影の描画のため</dt>
<dt>よりリアルな影を描画する為に、影の品質の高いソフトシャドウを描画するVSMを導入しました。</dt>
<dt>実装方式</dt>
<dt>1.シャドウマップ描画用のレンダリングターゲットの作成</dt>
<dd>VSMでは、ライトから見た深度値と、ライトから見た深度値の2乗の二つのパラメータを書き込む必要があるため、カラーバッファーのフォーマットはRとGを書き込む事の出来るフォーマットを使用しています。</dd>
<dt>2.シャドウマップにシャドウマップ用のシェーダーを設定したモデルを描画する</dt>
<dd>次にシャドウマップに描画するモデルを描画します。モデルは、メインレンダリングターゲット用の描画モデルを作る際に作成してあるので、それを、ライトからみたビュープロジェクション行列を使用して描画します。<dd>
<dt>以下は実際に描画したシャドウマップの画像です。</dt>
<p><img src="image6.png" alt="alt text"></p>
<dt>3.作成されたシャドウマップ、ライトのデータ等から影を描画する</dt>
<dd>最後に、作成されたシャドウマップ等のデータから影を描画します。ライトのデータは元々一か所にまとめて、影描画用シェーダーのユーザー定数バッファーにデータを設定しているのでそれを使います。</dd>
<dt>以下は実際に描画された影の画像です。</dt>
<p><img src="image7.png" alt="alt text"></p>
<dt>工夫した点<dt>
<dt>シャドウマップの描画限界の問題</dt>
<dd>シャドウマップに送られているライトのビュープロジェクションは、描画の限界もあり、奥までキチンと描画されない問題がありました。この問題を解決するために、ライトのビュープロジェクションを作成しているカメラをプレイヤーに常に追従して、ライトのビュープロジェクションを更新する事で、プレイヤーがいる範囲には必ず影が描画されるように設計しました。</dd>
</dl>
</blockquote>
<br />
<p><a id = "anchor12"></a></p>
<h2 id="6-4%E7%AB%8B%E4%BD%93%E9%9F%B3">6-4.立体音</h2>
<blockquote>
<dl>
実装理由：クリーチャーの足音をよりリアルに見せるため
<dt>リアルなクリーチャーの足音を実装することで、緊張感の演出と、敵が近くにいるかどうかの判断ができて、遊びやすさも実現でき一石二鳥と考え実装しました。</dt>
<dt>実装方式</dt>
<dt>1.足音の立体的な計算の考案</dt>
<dd>まずは立体的に足音を鳴らすための計算を考えました。まずはクリーチャーの距離に応じて音量を増減する計算を制作しました。その後、その数値を状況によって違う数で累乗して、音を指数関数的に表現する事で、聞こえる音をよりリアルにしました。</dd>
<dt>2.累乗数値の変更</dt>
<dd>次に、状況に応じた累乗数値の変更プログラムを作成しました。こちらはクリーチャーのメタAIとして作成し、エネミーの位置とプレイヤーの位置を参照し、その間に壁があるか、視点がクリーチャーをとらえているか、を判定し、累乗数値の変更する事で、状況に応じた音の増減を表現することができました。そして様々な条件で聞こえる音が変化するので、ユーザーの注意が音へ向かいやすくなりより緊張感が増すようにしました。</dd>
<dt>以下は累乗数値を変更する条件の画像です
<p><img src="image8.png" alt="alt text"></p>
<dt>工夫した点</dt>
<dt>足音を鳴らすクリーチャーの選定</dt>
<dd>クリーチャーが複数追跡している状況では、足音が重なり音が割れてしまうのを防ぐ為に、足音を発生させるクリーチャーを限定するプログラムを作成しました。選定基準は追跡時かつプレイヤーに一番近いクリーチャーを選定するように設計しました。</dd>
</dl>
</blockquote>
<br />
<p><a id = "anchor13"></a></p>
<h2 id="6-5%E3%83%87%E3%83%90%E3%83%83%E3%82%B0%E6%A9%9F%E8%83%BD">6-5.デバッグ機能</h2>
<blockquote>
<p>実装理由:デバッグのため</p>
<p>今回の開発では、ifdef _DEBUGを使い、Debugの起動方式で自動的に
デバックのプログラムが実行されるようにした。</p>
<dl>
<dt>追加したデバッグ機能は</dt>
<dd>鉱石が採取可能かどうか画面に表示</dd>
<dd>鉱石採取時のコマンドステートを画面に表示</dd>
<dd>現在のエネミーのステートを色分けで画面に表示</dd>
<dd>カメラを一人称から三人称に切り替えるボタンを有効化(LB)</dd>
<dd>残り酸素量を時間で画面に表示</dd>
</dl>
</blockquote>
<br />
</body>
</html>
